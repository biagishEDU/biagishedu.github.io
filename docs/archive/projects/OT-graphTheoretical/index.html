<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="icon" type="image/png" href="../../../assets/ai.png" />

<meta name="author" content="Shayne Biagi">
<meta name="dcterms.date" content="2023-04-07">

<title>Shayne Biagi - Analysis of A Graph Theoretic Additive Approximation of Optimal Transport</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="https://biagishedu.github.io/">
    <span class="navbar-title">Shayne Biagi</span>
    </a>
  </div>
        <div class="quarto-navbar-tools ms-auto tools-wide">
    <a href="https://biagishedu.github.io/" rel="" title="Home" class="quarto-navigation-tool px-1" aria-label="Home"><i class="bi bi-house-fill"></i></a>
    <a href="../../index.html" rel="" title="Project Archive" class="quarto-navigation-tool px-1" aria-label="Project Archive"><i class="bi bi-archive-fill"></i></a>
    <a href="https://github.com/biagishEDU" rel="" title="My Github" class="quarto-navigation-tool px-1" aria-label="My Github"><i class="bi bi-github"></i></a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analysis of A Graph Theoretic Additive Approximation of Optimal Transport</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">optimal transport</div>
                <div class="quarto-category">transport theory</div>
                <div class="quarto-category">machine learning</div>
                <div class="quarto-category">mathematics</div>
                <div class="quarto-category">algorithms</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shayne Biagi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 7, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#description" id="toc-description" class="nav-link active" data-scroll-target="#description">Description</a>
  <ul class="collapse">
  <li><a href="#transforming-demand-and-supply-values" id="toc-transforming-demand-and-supply-values" class="nav-link" data-scroll-target="#transforming-demand-and-supply-values">Transforming Demand and Supply Values</a></li>
  <li><a href="#algorithm-for-scaled-demands-and-supplies" id="toc-algorithm-for-scaled-demands-and-supplies" class="nav-link" data-scroll-target="#algorithm-for-scaled-demands-and-supplies">Algorithm for Scaled Demands and Supplies:</a></li>
  </ul></li>
  <li><a href="#correctness" id="toc-correctness" class="nav-link" data-scroll-target="#correctness">Correctness</a></li>
  <li><a href="#efficiency" id="toc-efficiency" class="nav-link" data-scroll-target="#efficiency">Efficiency</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>In this post, I describe and analyze a graph theoretic additive approximation algorithm for approximating Optimal Transport. Nathaniel Lahn, Deepika Mulchandani, and Sharath Raghvendra (my former theory and algorithms professor) submitted this algorithm to the arXiv repository originally on May 28, 2019.</p>
<p>Please see the source below for the original paper on this algorithm.<br>
<a href="https://arxiv.org/abs/1905.11830">[A Graph Theoretic Additive Approximation of Optimal Transport]</a></p>
<p><img src="graphTheoretical.png" class="img-fluid"></p>
<section id="description" class="level2">
<h2 class="anchored" data-anchor-id="description">Description</h2>
<p>This algorithm applies the traditional framework of augmenting paths for computing an approximate solution to the minimum-cost maximum flow problem to a transport problem. However, in order to this, the problem must only contain integer supplies and demands. So, in order to utilize this algorithm, the input problem must first be transformed to contain only integer demands and supplies. The process of transforming the given problem’s demand and supply values follows:</p>
<section id="transforming-demand-and-supply-values" class="level3">
<h3 class="anchored" data-anchor-id="transforming-demand-and-supply-values">Transforming Demand and Supply Values</h3>
<p>Initially, let <span class="math inline">\(\varepsilon\)</span> be some constant value such that <span class="math inline">\(0 &lt; \varepsilon &lt; 1\)</span>, and set <span class="math inline">\(\alpha = \frac{2nC}{\varepsilon U \delta}\)</span>. Here, the variables are defined as follows:</p>
<ul>
<li><span class="math inline">\(n\)</span> is the total number of nodes.</li>
<li><span class="math inline">\(C\)</span> is the largest cost of any edge in the graph.</li>
<li><span class="math inline">\(U\)</span> is the total supply.</li>
<li><span class="math inline">\(\delta\)</span> is the additive error.</li>
</ul>
<p>Now, let <span class="math inline">\(\mathcal{I}\)</span> be the input for the transportation problem such that each demand node <span class="math inline">\(a \in A\)</span> has a demand of <span class="math inline">\(d_a\)</span> and each supply node <span class="math inline">\(b \in B\)</span> has a supply of <span class="math inline">\(s_b\)</span>. We will denote the integer-scaled demand for some node <span class="math inline">\(a \in A\)</span> as <span class="math inline">\(\overline{d}_a\)</span>. Similarly, the integer-scaled supply for some node <span class="math inline">\(b \in B\)</span> is denoted as <span class="math inline">\(\overline{s}_b\)</span>. The process to scale the demand and supply values at each node is detailed next. For all demand nodes <span class="math inline">\(a \in A\)</span>, <span class="math inline">\(\overline{d}_a = \lceil d_a\alpha\rceil\)</span>, and for all supply nodes <span class="math inline">\(b \in B\)</span>, <span class="math inline">\(\overline{s}_b = \lfloor s_b\alpha \rfloor\)</span>. Let <span class="math inline">\(\mathcal{I'}\)</span> denote this scaled input. Next, the solution to the scaled transport problem must be mapped to a feasible solution for the original demand and supply values. Let <span class="math inline">\(\sigma\)</span> denote any feasible maximum transport plan for the input <span class="math inline">\(\mathcal{I'}\)</span>. A transport plan <span class="math inline">\(\sigma\)</span> which sets, for each edge <span class="math inline">\((a,b),\sigma(a,b) = \sigma'(a,b)/\alpha\)</span>, is not necessarily a feasible or a maximum solution. <span class="math inline">\(\sigma\)</span> may not be a maximum solution, as there may be an excess supply remaining at a supply node. Similarly, <span class="math inline">\(\sigma\)</span> is not feasible as there may be excess supply that reaches a demand node. In order to convert <span class="math inline">\(\sigma\)</span> to a feasible and maximum solution, there are two steps:</p>
<ol type="1">
<li><p>First, we must convert <span class="math inline">\(\sigma\)</span> to a feasible solution. To do this, we can iteratively remove excess supply at demand nodes. For instance, let <span class="math inline">\(\mathcal{k}_a\)</span> denote the excess supply that reaches a demand node <span class="math inline">\(a \in A\)</span>. Now, iteratively select an arbitrary edge incident on <span class="math inline">\(a\)</span>. Let <span class="math inline">\((a,b)\)</span> denote this edge. Now, reduce <span class="math inline">\(\sigma(a,b)\)</span> and <span class="math inline">\(\mathcal{k}_a\)</span> by <span class="math inline">\(min{\mathcal{k}_a, \sigma(a,b)}\)</span>. Continue this until <span class="math inline">\(\mathcal{k}_a\)</span> is reduced to <span class="math inline">\(0\)</span>. We can then repeat these steps for all demand nodes <span class="math inline">\(a \in A\)</span> such that <span class="math inline">\(\mathcal{k}_a &gt; 0\)</span>. After this, <span class="math inline">\(\sigma\)</span> will have been converted to a feasible solution. At this point the total remaining supply in <span class="math inline">\(\sigma\)</span> is at most <span class="math inline">\(2n/\alpha\)</span>.</p></li>
<li><p>Second, we must convert the newly feasible solution, <span class="math inline">\(\sigma\)</span>, to a maximum transport plan. To do this, we just match the <span class="math inline">\(2n/\alpha\)</span> supplies arbitrarily to any leftover demands. This will incur a cost of at most <span class="math inline">\(C\)</span> per supply unit.</p></li>
</ol>
<p>Finally, with a properly scaled input, we can now apply the algorithm.</p>
</section>
<section id="algorithm-for-scaled-demands-and-supplies" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-for-scaled-demands-and-supplies">Algorithm for Scaled Demands and Supplies:</h3>
<p>First, initialize <span class="math inline">\(\sigma\)</span> as a transport plan, such that, for every edge <span class="math inline">\((a,b) \in A \times B\)</span>, <span class="math inline">\(\sigma(a,b) = 0\)</span>. Now, let the dual weight of some vertex <span class="math inline">\(v\)</span> be denoted as <span class="math inline">\(y(v)\)</span>. Set <span class="math inline">\(y(v) = 0\)</span> for all vertices <span class="math inline">\(v \in A \cup B\)</span>. This algorithm executes in <em>phases</em>, wherein each <em>phase</em> is two <em>steps</em>. Execution will terminate once <span class="math inline">\(\sigma\)</span> becomes a maximum transport plan. The two <em>steps</em> are detailed below:</p>
<ol type="1">
<li><p><strong>Hungarian Search:</strong><br>
In the first step, we will conduct a Hungarian Search in order to compute at least one augmenting path of admissible edges. Firstly, we will add two arbitrary nodes, <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, to the residual network. Here, <span class="math inline">\(s\)</span> represents a source node and <span class="math inline">\(t\)</span> represents a sink node for the single-source, single-sink maximum flow problem. We attach edges from <span class="math inline">\(s\)</span> to every free supply node and edges from every free demand node to <span class="math inline">\(t\)</span>. All edges incident on <span class="math inline">\(s\)</span> or <span class="math inline">\(t\)</span> are given a weight of <span class="math inline">\(0\)</span>. The weight of all other edges in the residual network are set the the slack of the respective edge based on the edge’s direction. Let <span class="math inline">\(\mathcal{G}_\sigma\)</span> denote the augmented residual network with the attached source and sink vertices. Now, execute Dijkstra’s algorithm from <span class="math inline">\(s\)</span> in the augmented residual network <span class="math inline">\(\mathcal{G}_\sigma\)</span>. Let <span class="math inline">\(\ell_v\)</span> be the shortest path in <span class="math inline">\(\mathcal{G}_\sigma\)</span> from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> for any node <span class="math inline">\(v \in A \cup B\)</span>. Now, we must update the dual weights in the network to maintain feasibility. For any vertex <span class="math inline">\(v \in A \cup B\)</span>, we will do one of the following:</p>
<ul>
<li><p>If <span class="math inline">\(\ell_v \geq \ell_t\)</span>, the dual weight is not updated.</p></li>
<li><p>Otherwise, the dual weight is updated. Now, if <span class="math inline">\(v \in A\)</span>, <span class="math inline">\(y(v) \leftarrow y(v) - \ell_t + \ell_v\)</span>. Else, if <span class="math inline">\(v \in B\)</span>, <span class="math inline">\(y(v) \leftarrow y(v) + \ell_t - \ell_v\)</span>.</p></li>
</ul>
<p>Once this step reaches completion, <span class="math inline">\(\sigma\)</span> remains feasible and the admissible graph contains at least one augmenting path.</p></li>
<li><p><strong>Partial DFS:</strong><br>
In the second step, we will compute at least one augmenting path and update <span class="math inline">\(\sigma\)</span> by augmenting it along every computed path. First, let <span class="math inline">\(\mathcal{A}\)</span> denote the admissible graph. Now, let <span class="math inline">\(X\)</span> denote the set of free supply nodes in the admissible graph <span class="math inline">\(\mathcal{A}\)</span>. A DFS will be iteratively run from every supply node in set <span class="math inline">\(X\)</span>. Let <span class="math inline">\(b \in X\)</span> be the supply node for the current iteration. The steps of the partial DFS from node <span class="math inline">\(b\)</span> are as follows:</p>
<ol type="a">
<li><p>Begin a DFS from node <span class="math inline">\(b\)</span>.</p></li>
<li><p>During the execution, if a free demand node is visited, then an augmenting path is found, and the DFS is terminated. Let <span class="math inline">\(P\)</span> denote this path. Once the DFS is terminated, all edges visited by the DFS, except for the edges of path <span class="math inline">\(P\)</span>, are removed. Then, we will augment <span class="math inline">\(\sigma\)</span> along path <span class="math inline">\(P\)</span> and updates set <span class="math inline">\(X\)</span> to contain only the set of free supply nodes remaining in admissible graph <span class="math inline">\(\mathcal{A}\)</span>.</p></li>
<li><p>If no augmenting path is found, all vertices and edges visited by the DFS are removed from admissible graph <span class="math inline">\(\mathcal{A}\)</span>, and set <span class="math inline">\(X\)</span> is updated to contain only the set of free supply nodes remaining in <span class="math inline">\(\mathcal{A}\)</span>.</p></li>
</ol>
<p>Once this step reaches completion, set <span class="math inline">\(X\)</span> will be empty.</p></li>
</ol>
<p>Finally, at the end of execution, <span class="math inline">\(\sigma\)</span> is a maximum transport plan for the given transport problem.</p>
</section>
</section>
<section id="correctness" class="level2">
<h2 class="anchored" data-anchor-id="correctness">Correctness</h2>
<p>To begin assessment of this algorithm’s correctness, we must first prove the following invariant:</p>
<p><em>In each phase of the algorithm, the partial DFS step computes at least one augmenting path. Once the partial DFS step terminates, there is no augmenting path in the admissible graph.</em></p>
<p>The proof is as follows:</p>
<p>Consider the shortest path from source node <span class="math inline">\(s\)</span> to sink node <span class="math inline">\(t\)</span> in the augmented residual network. Let <span class="math inline">\(P'\)</span> denote this path. Now, let <span class="math inline">\(b\)</span> be the free supply node after <span class="math inline">\(s\)</span> and let <span class="math inline">\(a\)</span> be the free demand node before <span class="math inline">\(t\)</span> along path <span class="math inline">\(P'\)</span>. Let <span class="math inline">\(P\)</span> denote the path from node <span class="math inline">\(b\)</span> to node <span class="math inline">\(a\)</span>.</p>
<p>First, we must show that path <span class="math inline">\(P\)</span> is an admissible augmenting path after the dual updates conducted by the Hungarian search. Note that, by construction, for any edge <span class="math inline">\((u,v)\)</span> in <span class="math inline">\(P\)</span>, <span class="math inline">\(\ell_u \leq \ell_t\)</span> and <span class="math inline">\(\ell_v \leq \ell_t\)</span>.</p>
<p>Let <span class="math inline">\(\tilde{y}(.)\)</span> denote the updated dual weight for some vertex. Now, the updated dual weights for vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> become:</p>
<ul>
<li><span class="math inline">\(\tilde{y}(u) = y(u) + \ell_t - \ell_u\)</span> and <span class="math inline">\(\tilde{y}(v) = y(v) - \ell_t + \ell_u\)</span> for a forward edge, or</li>
<li><span class="math inline">\(\tilde{y}(u) = y(u) - \ell_t + \ell_u\)</span> and <span class="math inline">\(\tilde{y}(v) = y(v) + \ell_t - \ell_u\)</span> for a backward edge.</li>
</ul>
<p>Now, the updated feasibility condition becomes:</p>
<ul>
<li><span class="math inline">\(\tilde{y}(u) + \tilde{y}(v) = y(u) + y(v) + \ell_v - \ell_u\)</span> for a forward edge, or</li>
<li><span class="math inline">\(\tilde{y}(u) + \tilde{y}(v) = y(u) + y(v) - \ell_v + \ell_u\)</span> for a backward edge.</li>
</ul>
<p>Note that all edges in the shortest path <span class="math inline">\(P\)</span> satisfy the condition that for any directed edge <span class="math inline">\((u,v)\)</span>, <span class="math inline">\(\ell_u + s(u,v) \geq \ell_v\)</span> where <span class="math inline">\(s(u,v)\)</span> is the slack of the respective edge. Because this condition holds with equality,</p>
<ul>
<li><span class="math inline">\(\tilde{y}(u) + \tilde{y}(v) = y(v) + y(v) + s(u,v) = \overline{c}(u,v) + 1\)</span> if <span class="math inline">\((u,v)\)</span> is a forward edge, or</li>
<li><span class="math inline">\(\tilde{y}(u) + \tilde{y}(v) = y(v) + y(v) - s(u,v) = \overline{c}(u,v)\)</span> if <span class="math inline">\((u,v)\)</span> is a backward edge.</li>
</ul>
<p>In other words, this means that path <span class="math inline">\(P\)</span> is an admissible augmenting path.</p>
<p>Finally, since the partial DFS initiates from every free supply vertex, including node <span class="math inline">\(b\)</span>, we will discover at least one augmenting path in the admissible graph.</p>
<p>After this, we must next show that once the partial DFS step terminates, there is no augmenting path in the admissible graph. During this step’s execution, graph <span class="math inline">\(\mathcal{A}\)</span>, initialized to the admissible graph, is maintained. For instance, after each execution of DFS, the edges visited by DFS are removed from graph <span class="math inline">\(\mathcal{A}\)</span> unless they are on the augmenting path <span class="math inline">\(P\)</span>. If no augmenting path is found, all edges visited by the DFS are removed from graph <span class="math inline">\(\mathcal{A}\)</span>. The termination condition of this step ensures that graph <span class="math inline">\(\mathcal{A}\)</span> does not have any free supply vertices remaining at completion.</p>
<p>Here, it is important to note that, every vertex removed from graph <span class="math inline">\(\mathcal{A}\)</span> is a vertex in which the DFS backtracked. Since it can be shown that there is no directed cycle consisting of admissible cycles, there is no path of admissible edges from any vertex which had been removed from graph <span class="math inline">\(\mathcal{A}\)</span> to a free demand node.</p>
<p>Now, as the partial DFS step ensures that all free supply vertices are deleted from graph <span class="math inline">\(\mathcal{A}\)</span> on completion, there cannot be admissible paths from any free supply vertex to a free demand vertex in the admissible graph. Now that we have proved this invariant, we can proceed to proving the correctness.</p>
<p>As the invariant above declares, in each phase, the algorithm will augment the transport plan by at least one unit of supply. So, it follows that, on termination of the algorithm, we will have computed a feasible maximum transport plan.</p>
<p>Firstly, we must show that all transport plans maintained by the algorithm will satisfy the following condition:</p>
<p><em>Considering a feasible maximum transport plan such that for every demand node</em> <span class="math inline">\(a \in A\)</span>, the dual weight <span class="math inline">\(y(a)\leq0\)</span>, and <span class="math inline">\(y(a) = 0\)</span> if node <span class="math inline">\(a\)</span> is free.</p>
<p>Denote this condition as (C).</p>
<p>Initially, for any node <span class="math inline">\(v\)</span> such that <span class="math inline">\(v \in A\)</span>, dual weights are set to <span class="math inline">\(0\)</span>. Within any phase, now suppose that <span class="math inline">\(\ell_v &lt; \ell_t\)</span>. Because of this, the dual weight of <span class="math inline">\(v\)</span> will be reduced when the Hungarian Search step updates dual weights.</p>
<p>So, since <span class="math inline">\(y(v)\)</span> was initially set to <span class="math inline">\(0\)</span>, after the update, <span class="math inline">\(y(v)\leq0\)</span>.</p>
<p>Next up, we must show that all free vertices of <span class="math inline">\(A\)</span> have a dual weight of <span class="math inline">\(0\)</span>, as specified by the aforementioned condition. As dual weights are initialized to <span class="math inline">\(0\)</span>, this claim is true initially. During execution of the algorithm, any vertex <span class="math inline">\(a \in A\)</span> whose demand has been met cannot become free through the remaining execution of the algorithm. So, we can argue that no free demand vertex will have its dual weight updated.</p>
<p>Now, note that, by construction, any directed edges to the sink node <span class="math inline">\(t\)</span> from a demand node in <span class="math inline">\(A\)</span> have zero cost in <span class="math inline">\(\mathcal{G}_\sigma\)</span>. Thus, it follows that there is a directed edge <span class="math inline">\((v,t)\)</span> with a cost of zero. So, <span class="math inline">\(\ell_t \leq \ell_v\)</span>, resulting in the dual weight <span class="math inline">\(y(v)\)</span> not being updated during the phase. Therefore, the algorithm maintains <span class="math inline">\(y(v) = 0\)</span> for every free demand node, and it is proved that the condition (C) is upheld. And so, finally, when the algorithm completes, we will have computed a feasible maximum transport plan which satisfies condition (C).</p>
</section>
<section id="efficiency" class="level2">
<h2 class="anchored" data-anchor-id="efficiency">Efficiency</h2>
<p>Before beginning an assessment of this algorithm’s efficiency, we must provide some lemmas. Also, at any stage in the algorithm, let <span class="math inline">\(B'\)</span> denote the set of free supply nodes and let <span class="math inline">\(A_F\)</span> denote the set of free demand nodes. The lemmas follow:</p>
<p><strong>Lemma 2.2:</strong> <em>The dual weight of any free supply node</em> <span class="math inline">\(v \in B'\)</span> is at most <span class="math inline">\(\lfloor 2C/\delta' \rfloor + 1\)</span></p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Suppose, for the sake of contradiction, that the free supply node <span class="math inline">\(b \in B\)</span> has a dual weight <span class="math inline">\(y(b) \geq \lfloor 2C/\delta' \rfloor + 2\)</span>. Now, consider the condition (C). Due to this condition, any free demand node <span class="math inline">\(a \in A_f\)</span> has a dual weight <span class="math inline">\(y(a)=0\)</span>. So, <span class="math inline">\(y(a) + y(b) \geq \lfloor 2C/\delta' \rfloor + 2 \geq \overline{c}(a,b) + 2\)</span>. However, this violates feasibility, as <span class="math inline">\(y(a) + y(b) \leq \overline{c}(a,b) + 1\)</span> is not upheld. Thus, a contradiction arises.&nbsp;◻</p>
</div>
<p><strong>Lemma 2.3:</strong> <em>The total number of phases in our algorithm is at most</em> <span class="math inline">\(\lfloor 2C/\delta' \rfloor + 1\)</span>.</p>
<p><em>Note:</em> Here, <span class="math inline">\(C\)</span> is the largest value in the cost matrix, <span class="math inline">\(\delta\)</span> is the additive error, and <span class="math inline">\(\delta' = (1-\varepsilon)\delta\)</span> where <span class="math inline">\(\varepsilon\)</span> is some constant such that <span class="math inline">\(0 &lt; \varepsilon &lt; 1\)</span>.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>From the invariant proved on the previous page, we can conclude that at the start of a phase, there are no admissible augmenting paths. Because of this, any path from source node <span class="math inline">\(s\)</span> to sink node <span class="math inline">\(t\)</span> in the augmented residual network <span class="math inline">\(\mathcal{G}_\sigma\)</span> will have a cost of at least 1. In other words <span class="math inline">\(\ell_t \geq 1\)</span>. Now, during any phase, let <span class="math inline">\(b \in B'\)</span> be any free supply node. It is important to note that node <span class="math inline">\(b\)</span> is also a free supply node in all previous phases. By construction, we may conclude that there exists a directed edge from <span class="math inline">\(s\)</span> to <span class="math inline">\(b\)</span> with a cost of <span class="math inline">\(0\)</span> in <span class="math inline">\(\mathcal{A}\)</span>. Therefore, <span class="math inline">\(\ell_b = 0\)</span>. Finally, since we now know that <span class="math inline">\(\ell_t \geq 1\)</span>, when updating the dual weight of node <span class="math inline">\(b\)</span> for this phase, the dual weight will be increased by at least <span class="math inline">\(1\)</span>. After <span class="math inline">\(\lfloor 2C/\delta' \rfloor + 2\)</span> phases, due to the aforementioned increase of at least <span class="math inline">\(1\)</span>, <span class="math inline">\(y(b) \geq \lfloor 2C/\delta' \rfloor + 2\)</span>, which contradicts Lemma 2.2 because <span class="math inline">\(\lfloor 2C/\delta' \rfloor + 2 &gt; \lfloor 2C/\delta' \rfloor + 1\)</span>.&nbsp;◻</p>
</div>
<p><strong>Lemma 2.4:</strong> <em>Let</em> <span class="math inline">\(\mathbb{P}\)</span> be the set of all augmenting paths produced by the algorithm. Then, <span class="math inline">\(\sum_{P\in\mathbb{P}} |P| = \mathcal{O}(\frac{nC^2}{\varepsilon(1-\varepsilon)\delta^2})\)</span>.</p>
<p><em>Note:</em> Here, <span class="math inline">\(C\)</span> is the largest value in the cost matrix, and <span class="math inline">\(\delta\)</span> is the additive error. Additionally, <span class="math inline">\(|P|\)</span> is the number of edges on path <span class="math inline">\(P\)</span>, and <span class="math inline">\(\varepsilon\)</span> is some constant such that <span class="math inline">\(0 &lt; \varepsilon &lt; 1\)</span>.</p>
<p>Now that the lemmas are out of the way, let us begin the assessment of this algorithm’s efficiency. First, Let <span class="math inline">\(\mathbb{P}_j\)</span> denote the set of all augmenting paths computed in phase <span class="math inline">\(j\)</span> of execution. Also, let <span class="math inline">\(\mathbb{P}\)</span> denote the set of all augmenting paths produced by the algorithm across all phases.</p>
<p>Consider Lemma 2.3. As described in the lemma, the total number of phases executed by the algorithm is bounded above by <span class="math inline">\(\lfloor 2C/\delta' \rfloor + 1\)</span>. So, the total number of phases is <span class="math inline">\(\mathcal{O}(C/\delta')\)</span>. Now, each phase consists of two steps: the Hungarian Search step and the partial DFS step.</p>
<p>In the Hungarian Search step, a single Dijkstra’s search is executed, taking <span class="math inline">\(\mathcal{O}(n^2)\)</span> time. The dual weight updates are insignificant to the complexity of this step.</p>
<p>Regarding the partial DFS step, note that during execution, any edge visited by the DFS is removed as long as it does not contribute to an augmenting path. Inversely, edges which do contribute to an augmenting path may be visited multiple times within the same phase. So, the time taken by the partial DFS step during phase <span class="math inline">\(j\)</span> becomes <span class="math inline">\(\mathcal{O}(n^2 + \sum_{P \in \mathbb{P}_j} |P|)\)</span>, where <span class="math inline">\(|P|\)</span> is the number of edges along the augmenting path <span class="math inline">\(P\)</span>. Thus, since we know that the number of total phases is <span class="math inline">\(\mathcal{O}(C/\delta')\)</span>, the total time taken by the algorithm across all phases is <span class="math inline">\(\mathcal{O}((C/\delta')n^2 + \sum_{P \in \mathbb{P}} |P|)\)</span>. Considering Lemma 2.4, wherein <span class="math inline">\(\sum_{P \in \mathbb{P}} |P| = \mathcal{O}(\frac{nC^2}{\varepsilon(1-\varepsilon)\delta^2})\)</span>, the total execution time of the algorithm is <span class="math inline">\(\mathcal{O}(\frac{n^2C}{(1-\varepsilon)\delta} + \frac{nC^2}{\varepsilon(1-\varepsilon)\delta^2})\)</span>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>