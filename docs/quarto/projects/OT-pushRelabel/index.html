<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shayne Biagi">
<meta name="dcterms.date" content="2023-04-10">

<title>Shayne Biagi - Analysis of A Push-Relabel Based Additive Approximation for Optimal Transport</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="https://biagishedu.github.io/web-portfolio/">
    <span class="navbar-title">Shayne Biagi</span>
    </a>
  </div>
        <div class="quarto-navbar-tools ms-auto">
    <a href="../../index.html" rel="" title="index.html" class="quarto-navigation-tool px-1" aria-label="index.html"><i class="bi bi-house-fill"></i></a>
    <a href="https://github.com/biagishEDU" rel="" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analysis of A Push-Relabel Based Additive Approximation for Optimal Transport</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">optimal transport</div>
                <div class="quarto-category">transport theory</div>
                <div class="quarto-category">machine learning</div>
                <div class="quarto-category">mathematics</div>
                <div class="quarto-category">algorithms</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shayne Biagi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 10, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#description" id="toc-description" class="nav-link active" data-scroll-target="#description">Description</a>
  <ul class="collapse">
  <li><a href="#transformation-procedure" id="toc-transformation-procedure" class="nav-link" data-scroll-target="#transformation-procedure">Transformation Procedure</a></li>
  </ul></li>
  <li><a href="#algorithm" id="toc-algorithm" class="nav-link" data-scroll-target="#algorithm">Algorithm</a>
  <ul class="collapse">
  <li><a href="#extending-the-algorithm-to-the-optimal-transport-problem" id="toc-extending-the-algorithm-to-the-optimal-transport-problem" class="nav-link" data-scroll-target="#extending-the-algorithm-to-the-optimal-transport-problem">Extending the Algorithm to the Optimal Transport Problem</a></li>
  </ul></li>
  <li><a href="#correctness" id="toc-correctness" class="nav-link" data-scroll-target="#correctness">Correctness</a></li>
  <li><a href="#efficiency" id="toc-efficiency" class="nav-link" data-scroll-target="#efficiency">Efficiency</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Optimal transport is quite expensive to compute exactly, so there have been recent desires for fast and reliable approximation algorithms. Here I analyze and describe a push-relabel based additive approximation algorithm for Optimal Transport. The paper I reference for this algorithm was originally submitted to the arXiv repository on Mar 7, 2022 by Nathaniel Lahn, Sharath Raghvendra (my former theory and algorithms professor), and Kaiyi Zhang. It is based on the push-relabel framework for min-cost flow problems. And unlike many other approaches, this algorithm can be parallelized for an even quicker execution time.</p>
<p>Please see the source below to check out the original paper.<br>
<a href="https://arxiv.org/abs/2203.03732">[A Push-Relabel Based Additive Approximation for Optimal Transport]</a></p>
<p><img src="pushRelabelGraph.png" class="img-fluid"></p>
<section id="description" class="level2">
<h2 class="anchored" data-anchor-id="description">Description</h2>
<p>The provided paper details a simple combinatorial approach to find an <span class="math inline">\(\varepsilon\)</span>-approximation of the Optimal Transport distance. The algorithm is based on the push-relabel framework for min-cost flow problems. This algorithm aims to reduce the numerical instabilities present in the Sinkhorn method of approximating optimal transport. Similar to before, in order to apply this algorithm, the input problem must be transformed so that all edge costs equal a <span class="math inline">\(\varepsilon\)</span> integer multiple and all nodes are given a dual label. The transformation procedure is detailed below:</p>
<section id="transformation-procedure" class="level3">
<h3 class="anchored" data-anchor-id="transformation-procedure">Transformation Procedure</h3>
<p>Initially, the input will be a bipartite graph. Let <span class="math inline">\(G\)</span> be this input graph, with two sets of nodes <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Nodes in set <span class="math inline">\(A\)</span> are referred to as demand nodes, and nodes in set <span class="math inline">\(B\)</span> are referred to as supply nodes.</p>
<p>First, we must convert edge costs to integer multiples of <span class="math inline">\(\varepsilon\)</span>, where <span class="math inline">\(\varepsilon\)</span> is some constant such that <span class="math inline">\(\varepsilon&gt;0\)</span>. Let <span class="math inline">\(c(u,v)\)</span> denote the cost of edge <span class="math inline">\((u,v)\)</span>, and <span class="math inline">\(\overline{c}(u,v)\)</span> denote the transformed edge cost. For every edge <span class="math inline">\((u,v) \in A \times B\)</span>, we must transform the edge cost such that, <span class="math inline">\(\overline{c}(u,v) = \varepsilon\lfloor c(u,v) / \varepsilon \rfloor\)</span></p>
<p>In addition to this, we must assign dual weights to every vertex <span class="math inline">\(v \in A \cup B\)</span>. These dual weights must satisfy a set of feasibility conditions. A matching <span class="math inline">\(M\)</span> is considered <span class="math inline">\(\varepsilon\)</span>-feasible, if for every edge <span class="math inline">\((a,b) \in A \times B\)</span>:</p>
<ul>
<li><span class="math inline">\(y(a) + y(b) \leq \overline{c}(a,b) + \varepsilon\)</span> if edge <span class="math inline">\((a,b)\)</span> is not in the matching <span class="math inline">\(M\)</span>.</li>
<li>or <span class="math inline">\(y(a) + y(b) = \overline{c}(a,b)\)</span> if edge <span class="math inline">\((a,b)\)</span> is in the matching <span class="math inline">\(M\)</span>.</li>
</ul>
</section>
</section>
<section id="algorithm" class="level2">
<h2 class="anchored" data-anchor-id="algorithm">Algorithm</h2>
<p>Dual weights for every supply node <span class="math inline">\(b\in B\)</span> are initialized such that <span class="math inline">\(y(b) = \varepsilon\)</span>. Similarly, dual weights for every demand node <span class="math inline">\(a\in A\)</span> are initialized such that <span class="math inline">\(y(a) = 0\)</span>. Finally, we will initialize the matching <span class="math inline">\(M\)</span> to be empty. In other words, <span class="math inline">\(M = \emptyset\)</span>.</p>
<p>This algorithm executes in phases, wherein each phase consists of three steps. In each phase, the algorithm will construct a set of free supply nodes, consisting of all free nodes from set <span class="math inline">\(B\)</span>. Let <span class="math inline">\(B'\)</span> denote this set of free supply nodes. If <span class="math inline">\(|B'| \leq \varepsilon n\)</span>, then <span class="math inline">\(M\)</span> is an <span class="math inline">\(\varepsilon\)</span>-feasible matching and the algorithm will arbitrarily match the remaining free vertices and return the new matching. In the case that <span class="math inline">\(|B'| &gt; \varepsilon n\)</span>, the algorithm will continue by computing a subset of admissible edges with at least least one end point in the free supply node set <span class="math inline">\(B'\)</span>.</p>
<p>Let <span class="math inline">\(E\)</span> denote the full set of admissible edges in the graph, and let <span class="math inline">\(E'\)</span> denote the set of admissible edges with at least least one end point in the free supply node set <span class="math inline">\(B'\)</span>. It follows that <span class="math inline">\(E' \subseteq E\)</span>. Finally, let <span class="math inline">\(A'\)</span> denote the set of demand nodes that participate in at least on edge in <span class="math inline">\(E'\)</span>. In other words <span class="math inline">\(A' = \{a|a \in A\)</span> and <span class="math inline">\((a,b) \in E' \}\)</span>. Now, the following steps are executed by the algorithm:</p>
<ol type="1">
<li><p><em>Greedy Step:</em> Computes a maximal matching <span class="math inline">\(M'\)</span> in the graph <span class="math inline">\(G'(A' \cup B', E')\)</span>.</p></li>
<li><p><em>Matching Update:</em> Let <span class="math inline">\(A''\)</span> denote the set of nodes in <span class="math inline">\(A'\)</span> which are present in both <span class="math inline">\(M\)</span> and <span class="math inline">\(M'\)</span>. Also, let <span class="math inline">\(M''\)</span> denote the set of edges in <span class="math inline">\(M\)</span> that are incident on some node in <span class="math inline">\(A''\)</span>. The algorithm will add the edges of <span class="math inline">\(M'\)</span> to <span class="math inline">\(M\)</span> and remove the edges of <span class="math inline">\(M''\)</span> from <span class="math inline">\(M\)</span>.</p></li>
<li><p><em>Dual Weight Update:</em> Let <span class="math inline">\(\overline{y}(v)\)</span> denote the updated dual weight of some node <span class="math inline">\(v\)</span>. For every edge <span class="math inline">\((a,b) \in M'\)</span>, the dual weight of node <span class="math inline">\(a\in A\)</span> will be updated such that <span class="math inline">\(\overline{y}(a) = y(a) - \varepsilon\)</span>. Additionally, for every node <span class="math inline">\(b\in B\)</span> in the set <span class="math inline">\(B'\)</span> such that <span class="math inline">\(b\)</span> is free with respect to <span class="math inline">\(M'\)</span>, the dual weight of node <span class="math inline">\(b\)</span> will be updated such that <span class="math inline">\(\overline{y}(b) = y(b) + \varepsilon\)</span>.</p></li>
</ol>
<section id="extending-the-algorithm-to-the-optimal-transport-problem" class="level3">
<h3 class="anchored" data-anchor-id="extending-the-algorithm-to-the-optimal-transport-problem">Extending the Algorithm to the Optimal Transport Problem</h3>
<p>With some instance <span class="math inline">\(\mathcal{I}\)</span> of the optimal transport problem, we can scale the supplies and demands at each node by some multiplicative factor of <span class="math inline">\(\Theta\)</span>. Doing so will not delegitimize the optimal transport plan, as the cost of the optimal transport plan will simply be increased by a factor of <span class="math inline">\(\Theta\)</span>.</p>
<p>Now, we can choose <span class="math inline">\(\Theta = 4n/\varepsilon\)</span>, and transform supply and demand values to integer values. To transform the supply and demand values, we can just round supply values down and round demand values up to the nearest integers.</p>
<p>Next, we create a matching instance by replacing each node with a group of nodes, such that the total of number of replacement nodes equals the respective supply or demand value of the original node. Each node in the replacement group will be set to have a supply or demand value of exactly 1.</p>
<p>Then, let <span class="math inline">\(\mathcal{A}\)</span> and <span class="math inline">\(\mathcal{B}\)</span> be the multi-set of the demand and supply nodes we just produced. Let this new instance of the <em>unbalanced matching problem</em> be denoted by <span class="math inline">\(\mathcal{I'}\)</span>. Now, we can solve the problem instance <span class="math inline">\(\mathcal{I'}\)</span> with the aforementioned algorithm.</p>
</section>
</section>
<section id="correctness" class="level2">
<h2 class="anchored" data-anchor-id="correctness">Correctness</h2>
<p>Before beginning an assessment of this algorithm’s correctness, we must define some invariants which the algorithm maintains. The invariants and their respective proofs follow:</p>
<p>(Invariant 1): <em>For every node</em> <span class="math inline">\(b\in B\)</span>, <span class="math inline">\(y(b) \geq 0\)</span>. In other words, every node in set <span class="math inline">\(B\)</span> has a non-negative dual weight. Additionally, for every node <span class="math inline">\(a\in A\)</span>, <span class="math inline">\(y(a) \leq 0\)</span>. In other words, every node in set <span class="math inline">\(A\)</span> is associated with a non-positive dual weight. Furthermore, every free node in set <span class="math inline">\(A\)</span> is associated with a dual weight of 0.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that the invariant is true at the start of the algorithm. This is true because dual weights for all nodes in set <span class="math inline">\(B\)</span> are initialized to <span class="math inline">\(\varepsilon\)</span> and are thus non-negative, and dual weights for all nodes in set <span class="math inline">\(A\)</span> are initialized to <span class="math inline">\(0\)</span> and are thus non-positive. Also, all nodes in set <span class="math inline">\(A\)</span> are initially free as the matching <span class="math inline">\(M\)</span> is initialized to the empty set. Now, inductively assume that the invariant holds at the start of every phase. Next, we must show that the invariant continues to hold at the end of any given phase. Firstly, consider the dual weight update step. When updated, nodes from set <span class="math inline">\(B\)</span> are increased by a factor of <span class="math inline">\(\varepsilon\)</span>, while nodes from set <span class="math inline">\(A\)</span> are decreased by the same factor. Thus, it follows that, as execution progresses, dual weights for nodes in set <span class="math inline">\(B\)</span> strictly increase and dual weights for nodes in set <span class="math inline">\(A\)</span> strictly decrease. So, dual weights for nodes in <span class="math inline">\(B\)</span> will remain non-negative, and dual weights for nodes in <span class="math inline">\(A\)</span> will remain non-positive. Now, we must show that every free node in set <span class="math inline">\(A\)</span> with respect to the matching <span class="math inline">\(M\)</span> will continue to retain a dual weight of <span class="math inline">\(0\)</span>. Computing the maximal matching in the <em>greedy step</em> will not affect this condition. Regarding the <em>matching update</em> step, we can conclude that after the matching <span class="math inline">\(M\)</span> has been updated, any node of set <span class="math inline">\(A\)</span> which was matched before the update will remain matched post-update. Because of this, we can further conclude that dual weights for every free node in set <span class="math inline">\(A\)</span> retain zero values. Finally, regarding the <em>dual weight update</em> step, dual weights of nodes from set <span class="math inline">\(A\)</span> are only reduced if said node it matched in <span class="math inline">\(M'\)</span>. And, since the previous step will have added edges of <span class="math inline">\(M'\)</span> to <span class="math inline">\(M\)</span>, every node in <span class="math inline">\(A\)</span> whose dual weight is updated will be matched in <span class="math inline">\(M\)</span> post-update. Thus, dual weights for all free nodes in set <span class="math inline">\(A\)</span> will retain a zero value.&nbsp;◻</p>
</div>
<p>(Invariant 2): <em>The matching</em> <span class="math inline">\(M\)</span> and a set of dual weights maintains <span class="math inline">\(\varepsilon\)</span>-feasibility.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that the invariant is true at the start of the algorithm, as all <span class="math inline">\(\varepsilon\)</span>-feasibility conditions are maintained in initializing <span class="math inline">\(M\)</span> and the set of dual weights. Now, inductively assume that the invariant holds at the start of every phase. Next, we must show that the invariant continues to hold at the end of any given phase. So, we must show that edges remain feasible through a phase. To do this, we need to show that the slack of all edges remains non-negative and all edges in the matching <span class="math inline">\(M\)</span> have zero slack. Let <span class="math inline">\(s(a,b)\)</span> denote the slack of edge <span class="math inline">\((a,b)\)</span>. Computing the maximal matching in the <em>greedy step</em> will not affect this condition. Only the <em>matching update</em> and <em>dual weight update</em> steps may violate feasibility. Consider an edge <span class="math inline">\((a,b)\)</span> which is feasible but not admissible at the beginning of a phase. In other words <span class="math inline">\(s(a,b) \geq \varepsilon\)</span>. As the matching <span class="math inline">\(M'\)</span> contains only admissible edges, edge <span class="math inline">\((a,b)\)</span> cannot be in <span class="math inline">\(M'\)</span> nor <span class="math inline">\(M\)</span>. Now, the dual weights of nodes <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> may be updated. If the dual weight <span class="math inline">\(y(a)\)</span> is updated, <span class="math inline">\(y(a)\)</span> will only be reduced by <span class="math inline">\(\varepsilon\)</span>, in turn increasing <span class="math inline">\(s(a,b)\)</span> by <span class="math inline">\(\varepsilon\)</span>. Here, <span class="math inline">\(s(a,b)\)</span> will retain a non-negative slack, and so feasibility is maintained. If the dual weight <span class="math inline">\(y(b)\)</span> is updated, <span class="math inline">\(y(b)\)</span> will only be increased by <span class="math inline">\(\varepsilon\)</span>, in turn decreasing <span class="math inline">\(s(a,b)\)</span> by <span class="math inline">\(\varepsilon\)</span>. As, <span class="math inline">\(s(a,b) \geq \varepsilon\)</span>, <span class="math inline">\(s(a,b)\)</span> will still be non-negative, and so feasibility is maintained. So, in the case that edge <span class="math inline">\((a,b)\)</span> is not admissible at the beginning of a phase, feasibility is maintained. Next, we must consider the case where edge <span class="math inline">\((a,b)\)</span> is admissible at the start of the phase. At the end of the phase, either <span class="math inline">\((a,b)\)</span> is or is not present in the updated matching <span class="math inline">\(M\)</span>. Both of these cases are detailed below:</p>
<ul>
<li><p>If <span class="math inline">\((a,b)\)</span> is present in <span class="math inline">\(M\)</span>, there are two possible cases. Either, <span class="math inline">\((a,b)\)</span> was in <span class="math inline">\(M\)</span> before the update or <span class="math inline">\((a,b)\)</span> is an edge in <span class="math inline">\(M'\)</span> which was added to the matching and thus exists in <span class="math inline">\(M\)</span> post-update. These further cases are detailed below.</p>
<ul>
<li><p>If <span class="math inline">\((a,b)\)</span> was in <span class="math inline">\(M\)</span> before the update, dual weights for nodes <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> remain unchanged. Thus, feasibility is maintained.</p></li>
<li><p>If <span class="math inline">\((a,b)\)</span> is an edge in <span class="math inline">\(M'\)</span> which was added to the matching during the update, then <span class="math inline">\((a,b) \in E'\)</span> was a non-matching admissible edge prior to the update. So, <span class="math inline">\(y(a)+y(b) = \overline{c}(a,b) + \varepsilon\)</span>. When the dual weights for both nodes are updated, <span class="math inline">\(y(a)\)</span> will be reduced by <span class="math inline">\(\varepsilon\)</span> and <span class="math inline">\(y(b)\)</span> will remain unchanged, maintaining feasibility. So, once the phase completes, every edge of <span class="math inline">\(M\)</span> retains feasibility.</p></li>
</ul></li>
<li><p>If <span class="math inline">\((a,b)\)</span> is not present in <span class="math inline">\(M\)</span>, there are two possible cases to explore. Either node <span class="math inline">\(b\)</span> is not present in set <span class="math inline">\(B'\)</span> or b is present in set <span class="math inline">\(B'\)</span>. These further cases are detailed below.</p>
<ul>
<li><p>In the case that node <span class="math inline">\(b\)</span> is not present in set <span class="math inline">\(B'\)</span>, the edge <span class="math inline">\((a,b)\)</span> satisfies feasibility at the start of a phase. When updating the dual weights of these nodes, only nodes which are present inset <span class="math inline">\(B'\)</span> are updated. And so, since node <span class="math inline">\(b\)</span> is not in <span class="math inline">\(B'\)</span>, <span class="math inline">\(y(b)\)</span> is left unchanged. Regarding node <span class="math inline">\(a\)</span>, <span class="math inline">\(y(a)\)</span> may be decreased by <span class="math inline">\(\varepsilon\)</span>, in turn increasing <span class="math inline">\(s(a,b)\)</span>. Thus, feasibility is always maintained.</p></li>
<li><p>In the case that node <span class="math inline">\(b\)</span> is present in set <span class="math inline">\(B'\)</span>, since <span class="math inline">\((a,b)\)</span> is admissible and is not in <span class="math inline">\(M\)</span> post-update, <span class="math inline">\((a,b)\)</span> cannot be in <span class="math inline">\(M'\)</span>. Now, consider the fact that <span class="math inline">\(M'\)</span> is a maximal matching. Because of this, node <span class="math inline">\(a\)</span> is matched with some other node <span class="math inline">\(b' \in M'\)</span>. So, if <span class="math inline">\(y(b)\)</span> is updated, and is thus increased by <span class="math inline">\(\varepsilon\)</span>, <span class="math inline">\(y(a)\)</span> will also updated, and thus will be decreased by <span class="math inline">\(\varepsilon\)</span>. Due to this, <span class="math inline">\(s(a,b)\)</span> remains non-negative, and feasibility is maintained.</p></li>
</ul></li>
</ul>
<p>&nbsp;◻</p>
</div>
<p>Now, finally that the invariants have been proven, we can continue to assess this algorithm’s correctness. Rounding edge costs in the manner described previously will introduce an error of <span class="math inline">\(\varepsilon n\)</span>. Then, after computing a matching of size at least <span class="math inline">\((1-\varepsilon)n\)</span>, when arbitrarily matching the last <span class="math inline">\(\varepsilon n\)</span> vertices, we incur an error no greater than <span class="math inline">\(\varepsilon n\)</span>. Finally, with reference to the following lemma (Lemma 3.1), we can conclude that the total error in the computed matching is no greater than <span class="math inline">\(+3\varepsilon n\)</span>. And thus, the matching is <span class="math inline">\(\varepsilon\)</span>-feasible.</p>
<p>Lemma 3.1: <em>The</em> <span class="math inline">\(\varepsilon\)</span>-feasible matching of size at least <span class="math inline">\((1-\varepsilon)n\)</span> that is computed by the algorithm is within an additive error of <span class="math inline">\(\varepsilon n\)</span> from the optimal matching with respect to the rounded edge costs.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(M\)</span> be the matching computed by the algorithm. Furthermore, let <span class="math inline">\(M_{OPT}\)</span> be the optimal matching with respect to the rounded edge costs. Considering the first feasibility condition and the fact that dual weights for all free vertices with respect to <span class="math inline">\(M\)</span> are non-negative we can conclude that: <span class="math inline">\(\sum_{(a,b)\in M} \overline{c}(a,b) = \sum_{(a,b)\in M}(y(a) + y(b)) \leq \sum_{v\in A\cup B} y(v)\)</span>. Now, as <span class="math inline">\(M_{OPT}\)</span> is a perfect matching, we can further conclude from the second feasibility condition that: <span class="math inline">\(\sum_{v\in A\cup B} y(v) = \sum_{(a,b)\in M_{OPT}}(y(a) + y(b)) \leq \sum_{(a,b)\in M_{OPT}}\overline{c}(a,b) + \varepsilon n\)</span>. And so, <span class="math inline">\(\sum_{(a,b)\in M} \overline{c}(a,b) \leq \sum_{(a,b)\in M_{OPT}}\overline{c}(a,b) + \varepsilon n\)</span>. Thus, conclusively, the matching <span class="math inline">\(M\)</span> is within an additive error of <span class="math inline">\(\varepsilon n\)</span> from the optimal matching with respect to rounded edge costs.&nbsp;◻</p>
</div>
</section>
<section id="efficiency" class="level2">
<h2 class="anchored" data-anchor-id="efficiency">Efficiency</h2>
<p>Before beginning an assessment of this algorithm’s efficiency, we must provide some lemmas. The lemmas and their respective proofs follow:</p>
<p>Lemma 3.2: <em>For any node</em> <span class="math inline">\(v \in A \cup B\)</span>, <span class="math inline">\(|y(v)| \leq (1+2\varepsilon\)</span>.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that the algorithm only ever increases the magnitude of any given dual weight. So, it is sufficient to show that the claim holds at the end of the algorithm. For all nodes in <span class="math inline">\(A \cup B\)</span>, there are only two cases to consider. Either, a node is present in set <span class="math inline">\(A\)</span> or in set <span class="math inline">\(B\)</span>. The two cases are described below:</p>
<ul>
<li><p>Let <span class="math inline">\(a\)</span> be some node such that <span class="math inline">\(a \in A\)</span>. If node <span class="math inline">\(a\)</span> is free, then the claim holds true due to Invariant 1. Now, if node <span class="math inline">\(a\)</span> is not free, and is thus matched to some node <span class="math inline">\(b \in B\)</span>, edge <span class="math inline">\((a,b)\)</span> is feasible. Because edge <span class="math inline">\((a,b)\)</span> is feasible, we can conclude that <span class="math inline">\(y(a) = \overline{c}(a,b) - y(b) \geq -y(b) \geq -(1+2\varepsilon)\)</span>. So, <span class="math inline">\(|y(a)| \leq (1+2\varepsilon)\)</span>.</p></li>
<li><p>Let <span class="math inline">\(a\)</span> be some free node at the start of the final phase of the algorithm such that <span class="math inline">\(a \in A\)</span>. We know, from Invariant 1, that <span class="math inline">\(y(a) = 0\)</span>. Now, for every vertex <span class="math inline">\(b \in B\)</span>, edge <span class="math inline">\((a,b)\)</span> satisfies feasibility. And so, <span class="math inline">\(y(b) \leq \overline{c}(a,b) + \varepsilon - y(a) = \overline{c}(a,b) + \varepsilon \leq 1 + \varepsilon\)</span>. So, since dual weights for nodes in set <span class="math inline">\(B\)</span> are only ever updated adding <span class="math inline">\(\varepsilon\)</span>, the dual weight for any node <span class="math inline">\(b \in B\)</span> when the algorithm reaches completion is at most <span class="math inline">\(1 + \varepsilon + \varepsilon = (1 + 2\varepsilon)\)</span>.</p></li>
</ul>
<p>&nbsp;◻</p>
</div>
<p>Lemma 3.3: <em>The sum of the magnitude of the dual weights increases by at least</em> <span class="math inline">\(\varepsilon n_i\)</span> in each phase.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(b\)</span> be some node at the beginning of some phase such that <span class="math inline">\(b\in B'\)</span>. Now, once the phase completes, there are two cases we must consider. Either, node <span class="math inline">\(b\)</span> is still free or it has been matched. Both cases are detailed below:</p>
<ul>
<li><p>In the case that node <span class="math inline">\(b\)</span> is still free once the phase completes, <span class="math inline">\(|y(b)|\)</span> increases by <span class="math inline">\(\varepsilon\)</span>.</p></li>
<li><p>In the case that <span class="math inline">\(b\)</span> is no longer free once the phase completes, and thus has been matched to some arbitrary node <span class="math inline">\(a \in M'\)</span>, <span class="math inline">\(|y(a)|\)</span> increases by <span class="math inline">\(\varepsilon\)</span> as well.</p></li>
</ul>
<p>So, conclusively, we can see that each node in set <span class="math inline">\(B'\)</span> causes the dual weight magnitude of some vertex to increase by exactly <span class="math inline">\(\varepsilon\)</span>. Thus, the total dual weight increase in each phase is at least <span class="math inline">\(\varepsilon n_i\)</span>.&nbsp;◻</p>
</div>
<p>Lemma 3.4: <em>The execution time of each phase is</em> <span class="math inline">\(O(n \times n_i)\)</span>.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that computing the set of free vertices at the start of each phase can be done in <span class="math inline">\(O(n)\)</span> time. Now, consider the <em>greedy step</em>. Initially, the algorithm must compute a maximal matching in the graph <span class="math inline">\(G'(A' \cup B', E')\)</span>. To construct this graph, we can scan over all edges incident to nodes in <span class="math inline">\(B'\)</span>, taking <span class="math inline">\(O(n \times n_i)\)</span> time. Then, the algorithm will find the maximal matching by processing each free node <span class="math inline">\(b \in B'\)</span>. The algorithm will then attempt to match node <span class="math inline">\(b\)</span> by finding the first edge <span class="math inline">\((a,b)\)</span> in the graph such that <span class="math inline">\(a\)</span> is not present in <span class="math inline">\(M'\)</span>. If such an edge is found, it is then added to <span class="math inline">\(M'\)</span>. If such an edge cannot be found, then node <span class="math inline">\(b\)</span> cannot be matched in <span class="math inline">\(M'\)</span>. Once every node in <span class="math inline">\(B'\)</span> has been processed, <span class="math inline">\(M'\)</span> is maximal. In this step, the only procedure significant to the execution time is that which constructs graph <span class="math inline">\(G'\)</span> in <span class="math inline">\(O(n \times n_i)\)</span> time. So, this step executes in <span class="math inline">\(O(n \times n_i)\)</span> time.</p>
<p>Next, consider the <em>matching update</em> and <em>dual weight update</em> steps. Since any matching has a size which is <span class="math inline">\(O(n)\)</span> and each node’s dual weight is updated at most once within any given phase, executing both of these steps will cost <span class="math inline">\(O(n)\)</span> time. Finally, the execution time of the entire phase comes out to be <span class="math inline">\(O( (n \times n_i) + n ) = O(n \times n_i)\)</span>.&nbsp;◻</p>
</div>
<p>Now, given the lemmas, we can continue assessing the overall execution time of the algorithm. Suppose that the algorithm completes <span class="math inline">\(t\)</span> phases during runtime. Let <span class="math inline">\(n_i\)</span> denote the size of <span class="math inline">\(B'\)</span> in phase <span class="math inline">\(i\)</span> where <span class="math inline">\(i\)</span> is some integer such that <span class="math inline">\(1 &lt; i \leq t\)</span>. From the termination condition, we can conclude that phase <span class="math inline">\(i\)</span> is only executed if <span class="math inline">\(n_i &gt; \varepsilon n\)</span>. In other words, if the size of <span class="math inline">\(B'\)</span> is more than <span class="math inline">\(\varepsilon n\)</span>, the algorithm terminates. Now, from Lemma 3.2, we know that the magnitude of the dual weight of any node is at most <span class="math inline">\((1+2\varepsilon)\)</span>. So, we use this as an upper bound for the magnitude of the dual weight of any given node. Furthering this concept, we can see that the sum total of the dual weight magnitudes over all nodes is at most <span class="math inline">\(n(1+2\varepsilon)\)</span>. Also, from Lemma 3.3, we know that for some phase <span class="math inline">\(i\)</span>, the sum total of the dual weight magnitudes over all nodes increases by at least <span class="math inline">\(\varepsilon n_i\)</span>.</p>
<p>With these observations, it follows that: <span class="math inline">\(\sum_{i=1}^{t} n_i \leq n(1+2\varepsilon)/\varepsilon\)</span>. And, <span class="math inline">\(n(1+2\varepsilon)/\varepsilon\)</span> is <span class="math inline">\(O(n/\varepsilon)\)</span>. Now, from Lemma 3.4, we know that the execution time of any given phase is <span class="math inline">\(O(n \times n_i)\)</span>. So, the total sequential execution time of the algorithm becomes <span class="math inline">\(O(n \cdot \sum_{i=1}^{t} n_i) = O(n \cdot \frac{n}{\varepsilon}) = O (n^2/\varepsilon)\)</span>.</p>
<p>Regarding the execution time of the algorithm when run in parallel, note that the <em>matching update</em> and <em>dual weight update</em> steps are trivially parallelizable, making them execute in constant time. Thus, with a classical parallel program to find maximal matchings for the <em>greedy step</em> in <span class="math inline">\(O(\log n)\)</span> time, the execution time of the program becomes <span class="math inline">\(O(\log n/\varepsilon^2)\)</span>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>